# 物件的擴展
## 屬性的簡潔表示法
ES6 允許直接寫入變量和函數，作為對象的屬性和方法。這樣的書寫更加簡潔。

	var foo = 'bar';
	var baz = {foo};
	baz // {foo: "bar"}
	
	// 等同於
	var baz = {foo: "bar"};

上面代碼表明，ES6 允許在對象之中，只寫屬性名，不寫屬性值。這時，屬性值等於屬性名所代表的變量。下面是另一個例子。

	function f(x, y) {
	  return {x, y};
	}
	
	// 等同於
	function f(x, y) {
	  return {x: x, y: y};
	}
	
	f(1, 2) // Object {x: 1, y: 2}

除了屬性簡寫，方法也可以簡寫。

	var o = {
	  method() {
	    return "Hello!";
	  }
	};
	
	// 等同於
	var o = {
	  method: function() {
	    return "Hello!";
	  }
	};

下面是一個實際的例子。

	var birth = '2000/01/01';
	
	var Person = {
	  name: '张三',
	  //等同於 birth: birth
	  birth,
	  // 等同於 hello: function ()...
	  hello() { console.log('我的名字是', this.name); }
	};

這種寫法用於函數的返回值，將會非常方便。

	function getPoint() {
	  var x = 1;
	  var y = 10;
	  return {x, y};
	}
	
	getPoint()
	// {x:1, y:10}

CommonJS 模塊輸出變量，就非常合適使用簡潔寫法。

	var ms = {};
	
	function getItem (key) {
	  return key in ms ? ms[key] : null;
	}
	
	function setItem (key, value) {
	  ms[key] = value;
	}
	
	function clear () {
	  ms = {};
	}
	
	module.exports = { getItem, setItem, clear };
	// 等同於
	module.exports = {
	  getItem: getItem,
	  setItem: setItem,
	  clear: clear
	};

屬性的賦值器（setter）和取值器（getter），事實上也是採用這種寫法。

	var cart = {
	  _wheels: 4,
	
	  get wheels () {
	    return this._wheels;
	  },
	
	  set wheels (value) {
	    if (value < this._wheels) {
	      throw new Error('数值太小了！');
	    }
	    this._wheels = value;
	  }
	}

注意，簡潔寫法的屬性名總是字符串，這會導致一些看上去比較奇怪的結果。

	var obj = {
	  class () {}
	};
	
	// 等同於
	
	var obj = {
	  'class': function() {}
	};

上面代碼中，`class`是字串，所以不會因為它屬於關鍵字，而導致語法解析報錯。

如果某個方法的值是一個`Generator`函數，前面需要加上**星號**。

	var obj = {
	  * m(){
	    yield 'hello world';
	  }
	}

## 屬性名表達式
JavaScript 語言定義對象的屬性，有兩種方法。

	// 方法一
	obj.foo = true;
	
	// 方法二
	obj['a' + 'bc'] = 123;

上面代碼的方法一是直接用標識符作為屬性名，方法二是用表達式作為屬性名，這時要將表達式放在方括號之內。

但是，如果使用字面量方式定義對象（使用大括號），在 ES5 中只能使用方法一（標識符）定義屬性。

	var obj = {
	  foo: true,
	  abc: 123
	};

ES6 允許字面量定義對象時，用方法二（表達式）作為對象的屬性名，即把表達式放在方括號內。

	let propKey = 'foo';
	
	let obj = {
	  [propKey]: true,
	  ['a' + 'bc']: 123
	};

下面是另一個例子。

	var lastWord = 'last word';
	
	var a = {
	  'first word': 'hello',
	  [lastWord]: 'world'
	};
	
	a['first word'] // "hello"
	a[lastWord] // "world"
	a['last word'] // "world"

表達式還可以用於定義方法名。

	let obj = {
	  ['h'+'ello']() {
	    return 'hi';
	  }
	};
	
	obj.hello() // hi

注意，屬性名表達式與簡潔表示法，不能同時使用，會報錯。

	// 報錯
	var foo = 'bar';
	var bar = 'abc';
	var baz = { [foo] };
	
	// 正确
	var foo = 'bar';
	var baz = { [foo]: 'abc'};

## 方法的name屬性
函數的`name`屬性，返回函數名。對象方法也是函數，因此也有`name`屬性。

	var person = {
	  sayName() {
	    console.log(this.name);
	  },
	  get firstName() {
	    return "Nicholas"
	  }
	}
	
	person.sayName.name   // "sayName"
	person.firstName.name // "get firstName"

上面代碼中，方法的`name`屬性返回函數名（即方法名）。如果使用了取值函數，則會在方法名前加上`get`。如果是存值函數，方法名的前面會加上`set`。

有兩種特殊情況：`bind`方法創造的函數，`name`屬性返回“bound”加上原函數的名字；`Function`構造函數創造的函數，`name`屬性返回“anonymous”。

	(new Function()).name // "anonymous"
	
	var doSomething = function() {
	  // ...
	};
	doSomething.bind().name // "bound doSomething"

如果對象的方法是一個 Symbol 值，那麼`name`屬性返回的是這個 Symbol 值的描述。

	const key1 = Symbol('description');
	const key2 = Symbol();
	let obj = {
	  [key1]() {},
	  [key2]() {},
	};
	obj[key1].name // "[description]"
	obj[key2].name // ""

上面代碼中，`key1`對應的 Symbol 值有描述，`key2`沒有。

## `Object.is()`
ES5 比較兩個值是否相等，只有兩個運算符：相等運算符（`==`）和嚴格相等運算符（`===`）。它們都有缺點，前者會自動轉換數據類型，後者的`NaN`不等於自身，以及`+0`等於`-0`。JavaScript 缺乏一種運算，在所有環境中，只要兩個值是一樣的，它們就應該相等。

ES6 提出“Same-value equality”（同值相等）算法，用來解決這個問題。`Object.is`就是執行這個算法的新方法。它用來比較兩個值是否嚴格相等，與嚴格比較運算符（`===`）的行為基本一致。

	Object.is('foo', 'foo')
	// true
	Object.is({}, {})
	// false

不同之處只有兩個：一是`+0`不等於`-0`，二是`NaN`等於自身。

	+0 === -0 //true
	NaN === NaN // false
	
	Object.is(+0, -0) // false
	Object.is(NaN, NaN) // true

ES5 可以通過下面的代碼，部署`Object.is`。

	Object.defineProperty(Object, 'is', {
	  value: function(x, y) {
	    if (x === y) {
	      // 针对+0 不等于 -0的情况
	      return x !== 0 || 1 / x === 1 / y;
	    }
	    // 针对NaN的情况
	    return x !== x && y !== y;
	  },
	  configurable: true,
	  enumerable: false,
	  writable: true
	});

## `Object.assign()`


## 屬性的可枚舉性


## 屬性的遍歷


## `__proto__`屬性，`Object.setPrototypeOf()`，`Object.getPrototypeOf()`

## 物件的擴展運算符