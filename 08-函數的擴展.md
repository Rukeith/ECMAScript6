# 函數的擴展
## 函數參數的預設值
### 基本用法
在 ES6 之前，不能直接為函數的參數指定預設值，只能採用變通的方法。

	function log(x, y) {
	  y = y || 'World';
	  console.log(x, y);
	}

	log('Hello') // Hello World
	log('Hello', 'China') // Hello China
	log('Hello', '') // Hello World

上面代碼檢查函數 log 的參數 y 有沒有賦值，如果沒有，則指定預設值為 World。這種寫法的缺點在於，如果參數 y 賦值了，但是對應的布林值為`false`，則該賦值不起作用。就像上面代碼的最後一行，參數 y 等於空字符，結果被改為預設值。

為了避免這個問題，通常需要先判斷一下參數 y 是否被賦值，如果沒有，再等於預設值。這有兩種寫法。

	// 寫法一
	if (typeof y === 'undefined') {
	  y = 'World';
	}

	// 寫法二
	if (arguments.length === 1) {
	  y = 'World';
	}

ES6 允許為函數的參數設置預設值，即直接寫在參數定義的後面。

	function log(x, y = 'World') {
	  console.log(x, y);
	}

	log('Hello') // Hello World
	log('Hello', 'China') // Hello China
	log('Hello', '') // Hello

可以看到，ES6 的寫法比 ES5 簡潔許多，而且非常自然。下面是另一個例子。

	function Point(x = 0, y = 0) {
	  this.x = x;
	  this.y = y;
	}

	var p = new Point();
	p // { x: 0, y: 0 }

除了簡潔，ES6 的寫法還有兩個好處：首先，閱讀代碼的人，可以立刻意識到哪些參數是可以省略的，不用查看函數體或文檔；其次，有利於將來的代碼優化，即使未來的版本徹底拿掉這個參數，也不會導致以前的代碼無法運行。

參數變數是預設宣告的，所以不能用`let`或`const`再次宣告。

	function foo(x = 5) {
	  let x = 1; // error
	  const x = 2; // error
	}

上面代碼中，參數變數 x 是預設宣告的，在函數內中，不能用`let`或`const`再次宣告，否則會報錯。

### 與解構賦值預設值結合使用
參數預設值可以與解構賦值的預設值，結合起來使用。

	function foo({x, y = 5}) {
	  console.log(x, y);
	}

	foo({}) // undefined, 5
	foo({x: 1}) // 1, 5
	foo({x: 1, y: 2}) // 1, 2
	foo() // TypeError: Cannot read property 'x' of undefined

上面代碼使用了物件的解構賦值預設值，而沒有使用函數參數的預設值。只有當函數`foo`的參數是一個物件時，變數`x`和`y`才會通過解構賦值而生成。如果函數`foo`調用時參數不是物件，變數`x`和`y`就不會生成，從而報錯。如果參數物件沒有`y`屬性，`y`的預設值 5 才會生效。

	function fetch(url, { body = '', method = 'GET', headers = {} }){
	  console.log(method);
	}

	fetch('http://example.com', {})
	// "GET"

	fetch('http://example.com')
	// 報錯

上面代碼中，如果函數`fetch`的第二個參數是一個物件，就可以為它的三個屬性設置預設值。

上面的寫法不能省略第二個參數，如果結合函數參數的預設值，就可以省略第二個參數。這時，就出現了雙重預設值。

下面是另一個物件的解構賦值預設值的例子。

	function fetch(url, { method = 'GET' } = {}){
	  console.log(method);
	}

	fetch('http://example.com')
	// "GET"

上面代碼中，函數`fetch`沒有第二個參數時，函數參數的預設值就會生效，然後才是解構賦值的預設值生效，變數`method`才會取到預設值`GET`。

再請問下面兩種寫法有什麼差別？

	// 寫法一
	function m1({x = 0, y = 0} = {}) {
	  return [x, y];
	}

	// 寫法二
	function m2({x, y} = { x: 0, y: 0 }) {
	  return [x, y];
	}

上面兩種寫法都對函數的參數設定了預設值，區別是寫法一函數參數的預設值是空物件，但是設置了物件解構賦值的預設值；寫法二函數參數的預設值是一個有具體屬性的函數，但是沒有設置物件解構賦值的預設值。

	// 函數没有參數的情況
	m1() // [0, 0]
	m2() // [0, 0]

	// x 和 y 都有值的情况
	m1({x: 3, y: 8}) // [3, 8]
	m2({x: 3, y: 8}) // [3, 8]

	// x 有值，y 無值的情况
	m1({x: 3}) // [3, 0]
	m2({x: 3}) // [3, undefined]

	// x 和 y 都無值的情况
	m1({}) // [0, 0];
	m2({}) // [undefined, undefined]

	m1({z: 3}) // [0, 0]
	m2({z: 3}) // [undefined, undefined]

### 參數預設值的位置
通常情況下，定義了預設值的參數，應該是函數的尾部參數。因為這樣比較容易看出來，到底省略了哪些參數。如果非尾部的參數設置預設值，實際上這個參數是沒法省略的。

	// 例一
	function f(x = 1, y) {
	  return [x, y];
	}

	f() // [1, undefined]
	f(2) // [2, undefined])
	f(, 1) // 報錯
	f(undefined, 1) // [1, 1]

	// 例二
	function f(x, y = 5, z) {
	  return [x, y, z];
	}

	f() // [undefined, 5, undefined]
	f(1) // [1, 5, undefined]
	f(1, ,2) // 報錯
	f(1, undefined, 2) // [1, 5, 2]

上面代碼中，有預設值的參數都不是尾部參數。這時，無法只省略該參數，而不省略它後面的參數，除非輸入`undefined`。

如果傳入`undefined`，將觸發該參數等於預設值，`null`則沒有這個效果。

	function foo(x = 5, y = 6){
	  console.log(x,y);
	}

	foo(undefined, null)
	// 5 null

上面代碼中，`x`參數對應`undefined`，結果觸發了預設值，`y`參數等於`null`，就沒有觸發預設值。

### 函數的 length 屬性
指定了預設值以後，函數的`length`屬性，將返回沒有指定預設值的參數個數。也就是說，指定了預設值後，`length`屬性將失真。

	(function(a){}).length // 1
	(function(a = 5){}).length // 0
	(function(a, b, c = 5){}).length // 2

上面代碼中，`length`屬性的返回值，等於函數的參數個數減去指定了預設值的參數個數。比如，上面最後一個函數，定義了 3 個參數，其中有一個參數`c`指定了預設值，因此`length`屬性等於 3 減去 1，最後得到 2。

這是因為`length`屬性的含義是，該函數預期傳入的參數個數。某個參數指定預設值以後，預期傳入的參數個數就不包括這個參數了。同理，`rest`參數也不會計入`length`屬性。

	(function(...args) {}).length // 0

### 作用域
一個需要注意的地方是，如果參數預設值是一個變數，則該變數所處的作用域，與其他變數的作用域規則是一樣的，即先是當前函數的作用域，然後才是全局作用域。

	var x = 1;

	function f(x, y = x) {
	  console.log(y);
	}

	f(2) // 2

上面代碼中，參數`y`的預設值等於`x`。調用時，由於函數作用域內部的變數`x`已經生成，所以`y`等於參數`x`，而不是全局變數`x`。

如果調用時，函數作用域內部的變數`x`沒有生成，結果就會不一樣。

	let x = 1;

	function f(y = x) {
	  let x = 2;
	  console.log(y);
	}

	f() // 1

上面代碼中，函數調用時，`y`的預設值變數`x`尚未在函數內部生成，所以`x`指向全局變數，結果又不一樣。

如果此時，全局變數`x`不存在，就會報錯。

	function f(y = x) {
	  let x = 2;
	  console.log(y);
	}

	f() // ReferenceError: x is not defined

如果函數 A 的參數預設值是函數 B，由於函數的作用域是其宣告時所在的作用域，那麼函數 B 的作用域不是函數 A，而是全局作用域。請看下面的例子。

	let foo = 'outer';

	function bar(func = x => foo) {
	  let foo = 'inner';
	  console.log(func()); // outer
	}

	bar();

上面代碼中，函數`bar`的參數`func`，預設是一個匿名函數，返回值為變數`foo`。這個匿名函數的作用域就不是`bar`。這個匿名函數宣告時，是處在外層作用域，所以內部的`foo`指向函數體外的宣告，輸出outer。它實際上等同於下面的代碼。

	let foo = 'outer';
	let f = x => foo;

	function bar(func = f) {
	  let foo = 'inner';
	  console.log(func()); // outer
	}

	bar();

如果寫成下面這樣，就會報錯。

	function bar(func = () => foo) {
	  let foo = 'inner';
	  console.log(func());
	}

	bar() // ReferenceError: foo is not defined

### 應用
利用參數預設值，可以指定某一個參數不得省略，如果省略就拋出一個錯誤。

	function throwIfMissing() {
	  throw new Error('Missing parameter');
	}

	function foo(mustBeProvided = throwIfMissing()) {
	  return mustBeProvided;
	}

	foo()
	// Error: Missing parameter

上面代碼的`foo`函數，如果調用的時候沒有參數，就會調用預設值`throwIfMissing`函數，從而拋出一個錯誤。

從上面代碼還可以看到，參數`mustBeProvided`的預設值等於`throwIfMissing`函數的運行結果（即函數名之後有一對圓括號），這代表參數的預設值不是在定義時執行，而是在運行時執行（即如果參數已經賦值，預設值中的函數就不會運行），這與python語言不一樣。

另外，可以將參數預設值設為`undefined`，代表這個參數是可以省略的。

	function foo(optional = undefined) { ··· }

## `rest`參數
ES6 引入`rest`參數（形式為“...變數名”），用於獲取函數的多餘參數，這樣就不需要使用`arguments`物件了。`rest`參數搭配的變數是一個陣列，該變數將多餘的參數放入陣列中。

	function add(...values) {
	  let sum = 0;
	
	  for (var val of values) {
	    sum += val;
	  }
	
	  return sum;
	}
	
	add(2, 5, 3) // 10

上面代碼的`add`函數是一個求和函數，利用`rest`參數，可以向該函數傳入任意數目的參數。

下面是一個`rest`參數代替`arguments`變量的例子。

	// arguments 變數的寫法
	const sortNumbers = () =>
	  Array.prototype.slice.call(arguments).sort();
	
	// rest 參數的寫法
	const sortNumbers = (...numbers) => numbers.sort();

上面代碼的兩種寫法，比較後可以發現，`rest`參數的寫法更自然也更簡潔。

`rest`參數中的變數代表一個陣列，所以陣列特有的方法都可以用於這個變數。下面是一個利用`rest`參數改寫陣列`push`方法的例子。

	function push(array, ...items) {
	  items.forEach(function(item) {
	    array.push(item);
	    console.log(item);
	  });
	}
	
	var a = [];
	push(a, 1, 2, 3);

注意，`rest`參數之後不能再有其他參數（即只能是最後一個參數），否則會報錯。

	// 報錯
	function f(a, ...b, c) {
	  // ...
	}

函數的`length`屬性，不包括`rest`參數。

	(function(a) {}).length  // 1
	(function(...a) {}).length  // 0
	(function(a, ...b) {}).length  // 1

## 擴展運算符
### 含義
擴展運算符（spread）是三個點（`...`）。它好比`rest`參數的逆運算，將一個陣列轉為用逗號分隔的參數序列。

	console.log(...[1, 2, 3])
	// 1 2 3
	
	console.log(1, ...[2, 3, 4], 5)
	// 1 2 3 4 5
	
	[...document.querySelectorAll('div')]
	// [<div>, <div>, <div>]

該運算符主要用於函數調用。

	function push(array, ...items) {
	  array.push(...items);
	}
	
	function add(x, y) {
	  return x + y;
	}
	
	var numbers = [4, 38];
	add(...numbers) // 42

上面代碼中，`array.push(...items)`和`add(...numbers)`這兩行，都是函數的調用，它們的都使用了擴展運算符。該運算符將一個陣列，變為參數序列。

擴展運算符與正常的函數參數可以結合使用，非常靈活。

	function f(v, w, x, y, z) { }
	var args = [0, 1];
	f(-1, ...args, 2, ...[3]);

### 替代陣列的`apply`方法
由於擴展運算符可以展開陣列，所以不再需要`apply`方法，將陣列轉為函數的參數了。

	// ES5 的寫法
	function f(x, y, z) {
	  // ...
	}
	var args = [0, 1, 2];
	f.apply(null, args);
	
	// ES6 的寫法
	function f(x, y, z) {
	  // ...
	}
	var args = [0, 1, 2];
	f(...args);

下面是擴展運算符取代`apply`方法的一個實際的例子，應用`Math.max`方法，簡化求出一個陣列最大元素的寫法。

	// ES5 的寫法
	Math.max.apply(null, [14, 3, 77])
	
	// ES6 的寫法
	Math.max(...[14, 3, 77])
	
	// 等同于
	Math.max(14, 3, 77);

上面代碼表示，由於 JavaScript 不提供求陣列最大元素的函數，所以只能套用`Math.max`函數，將陣列轉為一個參數序列，然後求最大值。有了擴展運算符以後，就可以直接用`Math.max`了。

另一個例子是通過`push`函數，將一個陣列添加到另一個陣列的尾部。

	// ES5 的寫法
	var arr1 = [0, 1, 2];
	var arr2 = [3, 4, 5];
	Array.prototype.push.apply(arr1, arr2);
	
	// ES6 的寫法
	var arr1 = [0, 1, 2];
	var arr2 = [3, 4, 5];
	arr1.push(...arr2);

上面代碼的 ES5 寫法中，`push`方法的參數不能是陣列，所以只好通過`apply`方法變通使用`push`方法。有了擴展運算符，就可以直接將陣列傳入`push`方法。

下面是另外一個例子。

	// ES5
	new (Date.bind.apply(Date, [null, 2015, 1, 1]))
	// ES6
	new Date(...[2015, 1, 1]);

### 擴展運算符的應用
#### 合併陣列
擴展運算符提供了陣列合併的新寫法。

	// ES5
	[1, 2].concat(more)
	// ES6
	[1, 2, ...more]
	
	var arr1 = ['a', 'b'];
	var arr2 = ['c'];
	var arr3 = ['d', 'e'];
	
	// ES5 的合併陣列
	arr1.concat(arr2, arr3));
	// [ 'a', 'b', 'c', 'd', 'e' ]
	
	// ES6 的合併陣列
	[...arr1, ...arr2, ...arr3]
	// [ 'a', 'b', 'c', 'd', 'e' ]

#### 與解構賦值結合
擴展運算符可以與解構賦值結合起來，用於生成陣列。

	// ES5
	a = list[0], rest = list.slice(1)
	// ES6
	[a, ...rest] = list

下面是另外一些例子。

	const [first, ...rest] = [1, 2, 3, 4, 5];
	first // 1
	rest  // [2, 3, 4, 5]
	
	const [first, ...rest] = [];
	first // undefined
	rest  // []:
	
	const [first, ...rest] = ["foo"];
	first  // "foo"
	rest   // []

如果將擴展運算符用於陣列賦值，只能放在參數的最後一位，否則會報錯。

	const [...butLast, last] = [1, 2, 3, 4, 5];
	// 報錯
	
	const [first, ...middle, last] = [1, 2, 3, 4, 5];
	// 報錯

#### 函數的返回值
JavaScript 的函數只能返回一個值，如果需要返回多個值，只能返回陣列或物件。擴展運算符提供了解決這個問題的一種變通方法。

	var dateFields = readDateFields(database);
	var d = new Date(...dateFields);
 
上面代碼從資料庫取出一行資料，通過擴展運算符，直接將其傳入構造函數`Date`。

#### 字串
擴展運算符還可以將字串轉為真正的陣列。

	[...'hello']
	// [ "h", "e", "l", "l", "o" ]

上面的寫法，有一個重要的好處，那就是能夠正確識別 32 位的 Unicode 字符。

	'x\uD83D\uDE80y'.length // 4
	[...'x\uD83D\uDE80y'].length // 3

上面代碼的第一種寫法，JavaScript 會將 32 位 Unicode 字符，識別為 2 個字符，採用擴展運算符就沒有這個問題。因此，正確返回字串長度的函數，可以像下面這樣寫。

	function length(str) {
	  return [...str].length;
	}
	
	length('x\uD83D\uDE80y') // 3

凡是涉及到操作 32 位 Unicode 字符的函數，都有這個問題。因此，最好都用擴展運算符改寫。

	let str = 'x\uD83D\uDE80y';
	
	str.split('').reverse().join('')
	// 'y\uDE80\uD83Dx'
	
	[...str].reverse().join('')
	// 'y\uD83D\uDE80x'

上面代碼中，如果不用擴展運算符，字串的`reverse`操作就不正確。

#### 實現了 Iterator 接口的物件
任何 Iterator 接口的物件，都可以用擴展運算符轉為真正的陣列。

	var nodeList = document.querySelectorAll('div');
	var array = [...nodeList];

上面代碼中，`querySelectorAll`方法返回的是一個`nodeList`物件。它不是陣列，而是一個類似陣列的物件。這時，擴展運算符可以將其轉為真正的陣列，原因就在於`NodeList`物件實現了 Iterator 接口。

對於那些沒有部署 Iterator 接口的類似陣列的物件，擴展運算符就無法將其轉為真正的陣列。

	let arrayLike = {
	  '0': 'a',
	  '1': 'b',
	  '2': 'c',
	  length: 3
	};
	
	// TypeError: Cannot spread non-iterable object.
	let arr = [...arrayLike];

上面代碼中，`arrayLike`是一個類似陣列的物件，但是沒有部署 Iterator 接口，擴展運算符就會報錯。這時，可以改為使用`Array.from`方法將`arrayLike`轉為真正的陣列。

#### Map 和 Set 結構，Generator 函數
擴展運算符內部調用的是資料結構的 Iterator 接口，因此只要具有 Iterator 接口的物件，都可以使用擴展運算符，比如 Map 結構。

	let map = new Map([
	  [1, 'one'],
	  [2, 'two'],
	  [3, 'three'],
	]);
	
	let arr = [...map.keys()]; // [1, 2, 3]

`Generator`函數運行後，返回一個遍歷器對象，因此也可以使用擴展運算符。

	var go = function*(){
	  yield 1;
	  yield 2;
	  yield 3;
	};
	
	[...go()] // [1, 2, 3]

上面代碼中，變量`go`是一個`Generator`函數，執行後返回的是一個遍歷器物件，對這個遍歷器物件執行擴展運算符，就會將內部遍歷得到的值，轉為一個陣列。

如果對沒有 iterator 接口的物件，使用擴展運算符，將會報錯。

	var obj = {a: 1, b: 2};
	let arr = [...obj]; // TypeError: Cannot spread non-iterable object

## `name`屬性

## 箭頭函數

## 函數綁定

## 尾調用優化

## 函數參數的尾逗號
