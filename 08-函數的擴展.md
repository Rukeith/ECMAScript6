# 函數的擴展
## 函數參數的默認值
### 基本用法
在 ES6 之前，不能直接為函數的參數指定默認值，只能採用變通的方法。

	function log(x, y) {
	  y = y || 'World';
	  console.log(x, y);
	}
	
	log('Hello') // Hello World
	log('Hello', 'China') // Hello China
	log('Hello', '') // Hello World

上面代碼檢查函數 log 的參數 y 有沒有賦值，如果沒有，則指定默認值為 World。這種寫法的缺點在於，如果參數 y 賦值了，但是對應的布林值為`false`，則該賦值不起作用。就像上面代碼的最後一行，參數 y 等於空字符，結果被改為默認值。

為了避免這個問題，通常需要先判斷一下參數 y 是否被賦值，如果沒有，再等於默認值。這有兩種寫法。

	// 寫法一
	if (typeof y === 'undefined') {
	  y = 'World';
	}
	
	// 寫法二
	if (arguments.length === 1) {
	  y = 'World';
	}

ES6 允許為函數的參數設置默認值，即直接寫在參數定義的後面。

	function log(x, y = 'World') {
	  console.log(x, y);
	}
	
	log('Hello') // Hello World
	log('Hello', 'China') // Hello China
	log('Hello', '') // Hello

可以看到，ES6 的寫法比 ES5 簡潔許多，而且非常自然。下面是另一個例子。

	function Point(x = 0, y = 0) {
	  this.x = x;
	  this.y = y;
	}
	
	var p = new Point();
	p // { x: 0, y: 0 }

除了簡潔，ES6 的寫法還有兩個好處：首先，閱讀代碼的人，可以立刻意識到哪些參數是可以省略的，不用查看函數體或文檔；其次，有利於將來的代碼優化，即使未來的版本徹底拿掉這個參數，也不會導致以前的代碼無法運行。

參數變量是預設宣告的，所以不能用`let`或`const`再次聲明。

	function foo(x = 5) {
	  let x = 1; // error
	  const x = 2; // error
	}

上面代碼中，參數變量 x 是預設宣告的，在函數內中，不能用`let`或`const`再次聲明，否則會報錯。

## `rest`參數

## 擴展運算符

## `name`屬性

## 箭頭函數

## 函數綁定

## 尾調用優化

## 函數參數的尾逗號